<!DOCTYPE html>
<html lang="en">
<head>
    <link rel="stylesheet" href=".//kayq.css">
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Document</title>
</head>
<body>
    <div class="himnakan">
        <div class="texekutyun">
          <h1>կայքում կարող եք գտնել ծրագրավորմանը վերաբերվող բազմազան նյութեր</h1>
            <ul>
<li><a href="#lezuner">Ինչ է ծրագրավորումը</a></li>
  <li><a href="#computer">computer(Համակարգիչ)</a></li>
<li><a href="#stack"> Stack vs Heap Memory</a> </li>
<li><a href="#kompilator" >Compiler vs Interpreter</a></li>

            </ul>
        </div>
<div class="lezuner">            
<h2 id="lezuner">   
 Ինչ է ծրագրավորումը
    Ծրագրավորման լեզուներ
    Տիպեր և տարբերություններ
    Պրակտիկ կիրառությոն
</h2>
<p>
    <br/><strong>High-level vs. low-level-Բարձր մակարդակի եւ ցածր մակարդակի լեզուներ</strong>
    Ամենամեծ գործոնը, որ տարբերում է բարձր եւ ցածր մակարդակի ծրագրավորման լեզուները, այն է, թե արդյոք այդ լեզուն հեշտությամբ կարելի է հասկանալ մարդկային ծրագրավորողի կամ համակարգչի միջոցով։ Ցածր մակարդակի լեզուները մեքենայական են, ինչի շնորհիվ հիշողության օգտագործման տեսանկյունից դրանք շատ արդյունավետ են, բայց դժվար է հասկանալ առանց հավաքողի օգնության։ Քանի որ նրանք այնքան էլ հարմար չեն մարդկանց, նրանք այլեւս լայնորեն չեն օգտագործվում: Օրինակներից են մեքենայական կոդը եւ հավաքման լեզուները։
    <br/><strong> High-level languages</strong>,(Բարձր մակարդակի լեզուներ),մյուս կողմից, ավելի քիչ հիշողության արդյունավետ են, բայց շատ ավելի մարդկային բարեկամական: Դրա շնորհիվ նրանք ավելի հեշտությամբ են գրում, հասկանում, պահպանում եւ դեբուգ անում։ Այսօր գործածության մեջ գտնվող ամենատարածված ծրագրավորման լեզուները համարվում են բարձր մակարդակի լեզուներ:
<strong>Interpreted vs. compiled languages</strong>
    Մեկնաբանված եւ համակարգված լեզուների տարբերությունը կապված է այն բանի հետ, թե ինչպես են դրանք փոխակերպում բարձր մակարդակի կոդը եւ դարձնում այն համակարգչի կողմից մատչելի։ Մեկնաբանված լեզուների օգնությամբ կոդն անցնում է մի ծրագրի, որը կոչվում է ինտերպրետատոր, որը կարդում եւ իրականացնում է կոդի տողը տող առ տող։ Սա ավելի ճկուն եւ հարթակային դարձնելու հակվածություն ունի։
    interpreted-ի լեզուների օրինակներն են
    
<ul><li>Python</li>
   <li>JavaScript</li>
   <li> PHP</li>
<li> Ruby</li></ul> 
    Կոմպիլացված լեզուները անցնում են կառուցվող քայլով, որտեղ ամբողջ ծրագիրը վերածվում է մեքենայական կոդի: Սա ավելի արագ է իրագործում, բայց նաեւ նշանակում է, որ ցանկացած ժամանակ, երբ անհրաժեշտ է, պետք է նորից կազմել կամ «կառուցել» ծրագիրը։
    Կոմպիլացված լեզուների օրինակներն են
    
<ul>  <li>C++</li>
<li> C#</li>
<li> Rust</li>
<li>  Erlang</li></ul> 
    <strong> Տիպեր</strong>
    <br/><strong> 1. Procedural programming languages(Ընթացակարգային ծրագրավորման լեզուներ)</strong>
    Ընթացակարգային լեզուն հետեւում է հայտարարությունների կամ հրամանների հաջորդականությանը, որպեսզի հասնի ցանկալի արդյունքի: Քայլերի յուրաքանչյուր շարք կոչվում է ընթացակարգ, եւ այդ լեզուներից որեւէ մեկում գրված ծրագիրը կունենա մեկ կամ մի քանի ընթացակարգ դրա ներսում: Ընթացակարգային լեզուների ընդհանուր օրինակներն են.
    
    
<ul> 
<li> C++</li>
<li> Java</li>
<li> Pascal</li>
<li> BASIC</li></ul>
    <br/><strong>  2. Ֆունկցիոնալ ծրագրավորման լեզուներ</strong>
    Ֆունկցիոնալ լեզուները ոչ թե կենտրոնանում են դրույթների իրականացման վրա, այլ կենտրոնանում են մաթեմատիկական ֆունկցիաների եւ գնահատականների ելքի վրա։ Յուրաքանչյուր ֆունկցիա– կոդի վերամշակելի մոդուլ– կատարում է որոշակի առաջադրանք եւ վերադարձնում արդյունքը: Արդյունքը կփոխվի՝ կախված այն բանից, թե ինչ տվյալներ եք մուտքագրում ֆունկցիայի մեջ։ Որոշ հայտնի ֆունկցիոնալ ծրագրավորման լեզուներ ներառում են.
    
<ul><li> Scala</li>
<li>  Erlang</li>
<li>  Haskell</li>
<li>  Elixir</li>
<li> F#</li></ul>
<strong>3. Օբյեկտ կողմնորոշված ծրագրավորման լեզուներ</strong>
    Լեզվի այս տեսակը ծրագրային է վերաբերվում որպես տվյալների եւ ծրագրի տարրերից կազմված օբյեկտների խումբ, որը հայտնի է որպես հատկանիշներ եւ մեթոդներ: Օբյեկտները կարող են կրկին օգտագործվեն ծրագրի շրջանակներում կամ այլ ծրագրերում: Սա այն դարձնում է հայտնի լեզվի տեսակ բարդ ծրագրերի համար, քանի որ կոդը ավելի հեշտ է վերամշակել եւ մասշտաբավորել: Որոշ ընդհանուր օբյեկտ կողմնորոշված ծրագրավորման (OOP) լեզուները ներառում են.
<ul><li>Java</li>
<li>Python</li>
<li> PHP</li>
<li>  C++</li>
<li> Ruby</li></ul>
<strong> 4. Scripting languages</strong>
    Ծրագրավորողները սքրիփթային լեզուների միջոցով ավտոմատացնում են կրկնվող առաջադրանքները, կառավարում են դինամիկ վեբ կոնտենտը կամ աջակցում են ավելի մեծ ծրագրերում կատարվող գործընթացներին։ Որոշ ընդհանուր գրային լեզուներ ներառում են.
    
<ul><li> PHP</li>
<li> Ruby</li>
<li> Python</li>
<li> bash</li>
<li> Perl</li>
<li> Node.js</li></ul>
<strong>5. Տրամաբանական ծրագրավորման լեզուներ</strong>
  Փոխանակ համակարգչին ասելու, թե ինչ անել, տրամաբանական ծրագրավորման լեզուն արտահայտում է մի շարք փաստեր եւ կանոններ, որոնք կօգնեն համակարգչին, թե ինչպես որոշումներ կայացնել։ Լոգիական լեզուների որոշ օրինակներ ներառում են.
    
<ul><li> Prolog</li>
<li>Absys</li>
<li> Datalog</li>
<li> Alma-0</li></ul>
   <strong> Front-end vs. back-end լեզուներ</strong>
<strong>Front-end լեզուները</strong> հիմնականում մտահոգված են ծրագրային ապահովման «օգտագործող» ոլորտով: Առջեւի ծայրը վերաբերվում է բոլոր տեքստերին, գույներին, կոճակներին, պատկերներին եւ նավարկությանը, որոնց բախվելու է օգտագործողը ձեր կայքը կամ դիմումը կողմնորոշվելիս: Ցանկացած մարդ, ով ունի գրաֆիկական դիզայն կամ արվեստ, կարող է ավելի ոգեշնչվել՝ սկսելու սովորել առաջին շրջանի լեզուներից մեկը։
    Առաջային ծրագրավորման լեզուների որոշ օրինակներ ներառում են.
    
<ul><li> HTML</li>
<li>CSS</li>
<li> JavaScript</li>
<li> React</li></ul>
<strong>Back-end լեզուները</strong> վերաբերում են ծրագրային ապահովման սերվերի կողմի պահպանմանը եւ մանիպուլյացիային: Սա այն ծրագրի մի մասն է, որի հետ օգտվողը ուղղակիորեն չի շփվում, այլ աջակցում է նրանց փորձառությանը վարագույրների ետեւում։ Սա ներառում է տվյալների ճարտարապետությունը, սցենարը եւ կապը դիմումների եւ հիմքում ընկած տվյալների բազաների միջեւ:
    Ցանկացած մարդ, ով ունի մաթեմատիկայի կամ ճարտարագիտության փորձ, կարող է ավելի շատ հետաքրքրվել հետին զարգացմամբ։
    Back-end ծրագրավորման լեզուների որոշ օրինակներ ներառում են
    
<ul> <li>JavaScript</li>
<li>  PHP</li>
<li>Java</li>
<li> Python</li>
<li> Ruby</li>
<li>  C#</li></ul> </p>
</div>
<div class="computer"><p>
    <h1 id="computer">computer-Համակարգիչ</h1>
   <h2> Համակարգիչների դասակարգումն ըստ չափի</h2>
   <p>Վակուումային խողովակները կամ հատուկ հարմարեցված խողովակները
    - կամ նույնիսկ մեխանիկական կարգավորումը - օգտագործվել են համակարգիչների առաջին սերնդում:
    Դրանք ավելի դանդաղ էին, ավելի շատ էներգիա էին
    օգտագործում եւ ծրագրավորման առումով ավելի քիչ ճկուն էին։
    Դիսկրետ տրանզիստորները օգտագործվել են երկրորդ սերնդի համակարգիչներում,
    որոնք ավելի փոքր էին։ Նրանք նաեւ ավելի քիչ էներգիա էին ծախսում :
    Ինտեգրված շրջանները աշխատում էին երրորդ սերնդի համակարգիչներում։
    Յուրաքանչյուր ինտեգրալ շրջանի տրանզիստորների խտությունը 1960-ականների
    համակարգիչների եւ այսօրվա համակարգիչների միջեւ եղած հիմնական տարբերությունն է:
    Միկրոպրոցեսորներն օգտագործվում են չորրորդ սերնդի համակարգիչներում: Միկրոպրոցեսորներն օգտագործվում են,
    քանի որ միլիոնավոր ԻԿ-ներ լցված են մեկ սիլիկոնային չիպի վրա։ Անձնական բջջային սարքերի՝ լափթոփների,
    պլանշետների եւ սմարթֆոնների ներմուծմամբ համակարգիչների ձեւավորման գործոնը նվազել է, բարելավվել են
    առաջադրանքների մշակումը եւ գրաֆիկական թարգմանությունը, եւ այն դարձել է ավելի մարտկոցով աշխատող։
<h2> Համակարգիչների դասակարգումն ըստ նպատակի</h2>
    Միկրոհամակարգիչները, որոնք երբեմն հայտնի են որպես անհատական համակարգիչներ, քսաներորդ դարի վերջին
    դարձել են ամենատարածված տիպը։ «Միկրոհամակարգիչ» բառը ստեղծվել է միակուսակցական միկրոպրոցեսորային
    համակարգերի ներմուծմամբ։ Minicomputers, հայտնի է նաեւ որպես mid-range համակարգիչներ կամ Superminis,
    բազմաօգտագործվող համակարգչի տեսակ, որը ընկնում է ինչ-որ տեղ հաշվարկման սպեկտրի մեջտեղում։
    «supermini computer» տերմինը, կամ պարզապես «supermini», որը ստեղծվել է ավելի հզոր
    մինիհամակարգիչների նկարագրման համար, որոնք ունակ էին մրցել հիմնական ֆլմագների հետ:
    Սուպերհամակարգիչը համակարգիչ է, որը գտնվում է ընթացիկ մշակման հզորության կտրուկ ծայրին եւ կենտրոնացած է
    ծանր թվային հաշվարկներ պահանջող առաջադրանքներ կատարելու վրա։ «Supercomputer» բառը մի քիչ սխալ է: Այսօրվա
    գերհամակարգիչները հակված են դառնալ վաղվա միջին համակարգչի նշանը:
    Իրական թվերի մաթեմատիկական հավասարումների հաշվարկը լողացող կետային գործողության օրինակ է, որը չափվում է վայրկյանում
    լողացող կետով գործողություններով, կամ FLOPS-ով։ Այս համակարգիչները մշակվել են 1970-ականներին եւ ամենաարագ եւ ամենահզոր համակարգիչներն են։
<h2>Համակարգիչների դասակարգումն ըստ տեսակի</h2>
    սերվերը համակարգիչ է, որը նվիրված է մեկ կամ մի քանի ծառայություններ մատուցելուն եւ ենթադրվում է, որ այն վստահելի է,
    կարող է աշխատել մի քանի տարի եւ ունակ է սխալի դեպքում արժեքավոր դիագնոստիկա ապահովել: Ավելի փոքր սերվերներից շատերը
    պարզապես անձնական համակարգիչներ են, որոնք ստեղծվել են այլ համակարգիչներին ծառայություններ մատուցելու համար։
    Աշխատանքային բեմերը համակարգիչներ են, որոնք նախատեսված են մեկ օգտագործողին սպասարկելու համար եւ կարող են ներառել
    եզակի hardware առաջխաղացումներ, որոնք առկա չեն անձնական համակարգչի մեջ, ներկայումս արտահայտությունը օգտագործվում է
    բարձր արդյունավետությամբ սարքերի հետ աշխատասեղանի համակարգիչներին դիմելու համար:
    Տեղեկատվական սարքավորումները համակարգիչներ են, որոնք հատուկ կառուցված են որոշակի «օգտագործողի
    համար հարմար» աշխատանք կատարելու համար:Այս տերմինը հիմնականում օգտագործվում է մարտկոցով աշխատող շարժական սարքերի նկարագրման համար։
    Ներդրված համակարգիչները այն համակարգիչներն են, որոնք կառուցվում են մեխանիզմի կամ սարքի մեջ եւ հաճախ վարում են մի ծրագիր,
    որը պահվում է ոչ-ցցիկ հիշողության մեջ եւ բացառապես նախատեսված է այդ սարքավորումը գործարկելու համար:
<h2>Համակարգիչների դասակարգումն ըստ օգտագործման</h2>
    Հանրային համակարգիչը այն համակարգիչն է, որը հասանելի է հասարակությանը եւ, ընդհանուր առմամբ, կրակով պարսպապատված է
    եւ սահմանափակվում է միայն նախապես տեղադրված ծրագրերով։Անհատական համակարգիչը ունի միայն մեկ օգտատեր, ով ունի լիարժեք
    հասանելիություն բոլոր hardware ռեսուրսներին, ամբողջական վերահսկողություն է ապահովում համակարգչի բոլոր կողմերի նկատմամբ,
    ինչպես նաեւ կարող է տեղադրել եւ ջնջել ծրագիրը։ Անձնական ֆայլերը սովորաբար պահվում են անձնական համակարգիչներում:
    Կիսված համակարգիչը այն համակարգիչն է, որի վրա տարբեր ժամանակներում կարող են մուտք գործել բազմաթիվ անհատներ։
    Սակայն նրանք պետք է ունենային օգտագործողի անուններ եւ ծածկագրեր, որոնք նշանակվում էին երկար ժամանակ, իրենց
    տեսած ֆայլերով եւ համակարգչի պարամետրերով, որոնք հարմարեցված էին իրենց հատուկ հաշվին՝ ի տարբերություն հանրային համակարգիչների։
    Ցուցադրման համակարգիչները համակարգիչներ են, որոնք օգտագործվում են միայն սահմանափակ քանակությամբ ինֆորմացիա ցուցադրելու համար խանութում,
    հանդիպման կամ առեւտրի ցուցահանդեսում եւ հազվադեպ են հրավառվում։ Նման համակարգիչները սովորաբար օգտագործվում եւ պահպանվում են
    որպես սարքավորումներ, այլ ոչ թե որպես կարեւոր ֆայլերի հիմնական պահեստ։
<h2> Համակարգիչների դասակարգումը ըստ ֆունկցիայի</h2>
    Վաղ համակարգիչները պետք է օգտագործվեին միայն հաշվարկների համար։ Արդյունաբերական հեղափոխության սկզբում երկար,
    ձանձրալի աշխատանքներ ավտոմատացնելու համար կառուցվեցին որոշակի մեխանիկական սարքեր։ Բացի այդ, քսաներորդ դարի
    սկզբին բարդ էլեկտրամեքենաները կատարել են հատուկ անալոգային հաշվարկներ, իսկ առաջին թվային էլեկտրոնային
    հաշվարկային մեքենաները կառուցվել են World-ի ընթացքում
    Երկրորդ պատերազմ. Այդ ժամանակից ի վեր համակարգչային արագությունը, հզորությունը եւ բազմաչափությունը
    զգալիորեն աճել են, իսկ տրանզիստորների թիվը արագորեն աճում է։
    Ժամանակակից համակարգիչը սովորաբար բաղկացած է առնվազն մեկ պրոցեսորային տարրից եւ ինչ-որ տիպի
    համակարգչային հիշողությունից։ Մշակման տարրը կատարում է թվաբանական եւ տրամաբանական գործողություններ,
    իսկ հաջորդականության եւ վերահսկման միավորը փոխում է գործողությունների հաջորդականությունը՝ ի պատասխան պահպանված տվյալների։
    Մուտքային եւ ելքային սարքերը, ինչպես նաեւ երկու դերերը կատարող սարքերը պերիֆերիկ սարքեր են, որոնք թույլ են տալիս
    տեղեկատվությունը դուրս բերել արտաքին աղբյուրից եւ հնարավորություն են տալիս գործողությունների արդյունքը:
<h2>Համակարգիչների դասակարգում, ըստ չափի, օգտագործման, տեսակի և Նպատակի Բոլոր փաստերը</h2>
    Համակարգիչների դասակարգումը կարեւոր ուղղություն է հասկանալու համար այն սարքերի տարբեր տեսակները,
    որոնք այսօր առկա են շուկայում: Կարեւոր է նշել, որ համակարգիչների դասակարգումը հիմնված է մի քանի
    գործոնների վրա, ինչպիսիք են չափը, օգտագործումը, տեսակը եւ նպատակը։ Այս հոդվածում մանրամասնորեն
    կքննենք այս գործոնները եւ կներկայացնենք համակարգիչների դասակարգման ամբողջական պատկերացումը։
    Համակարգիչների դասակարգման ամենատարածված մեթոդներից մեկը հիմնված է չափերի վրա։ Համակարգիչների
    չափերը կարող են տարբերվել փոքր ձեռքի սարքերից մինչեւ հիմնական հիմնական համակարգիչները։
    Համակարգիչների ամենափոքր կատեգորիան հայտնի է որպես ձեռքի համակարգիչներ կամ անհատական թվային
    օգնականներ (PDAs)։ Այս սարքերը այնքան փոքր են, որ կարող են տեղավորվել ձեռքի ափի մեջ եւ սովորաբար
    օգտագործվում են անձնական գործերի համար, ինչպիսիք են գրաֆիկ կազմելը, գրառումներ անելը եւ ինտերնետից օգտվելը։
    Լապտերները եւ պլանշետները նույնպես համարվում են փոքր համակարգիչներ։ Դրանք ավելի հզոր են, քան ձեռքի սարքերը։
    Համակարգիչների դասակարգման մեկ այլ եղանակ էլ հիմնված է օգտագործման վրա։ Որոշ համակարգիչներ նախատեսված են
    հատուկ առաջադրանքների համար, ինչպիսիք են խաղային, գրաֆիկական դիզայնը կամ վիդեո խմբագրումը։ Այս համակարգիչները
    հայտնի են որպես հատուկ համակարգիչներ։ Սովորաբար նրանք ունեն բարձր վերջավորություն ունեցող սարքեր եւ ծրագրային
    ապահովում, որոնք օպտիմալացվում են հատուկ առաջադրանքների համար։ Մյուս կողմից, ընդհանուր նպատակային համակարգիչները
    նախատեսված են լայն շրջանակի համար եւ հարմար են ամենօրյա օգտագործման համար
    Համակարգիչների տեսակը նույնպես օգտագործվում է դրանք դասակարգելու համար։ Գոյություն ունի համակարգիչների
    երկու հիմնական տեսակ՝ անալոգ եւ թվային: Անալոգային համակարգիչները օգտագործվում են անընդհատ տվյալների
    մշակման համար, մինչդեռ թվային համակարգիչները օգտագործվում են դիսկրետ տվյալներ մշակելու համար։ Թվային
    համակարգիչներն ավելի լայն կիրառություն ունեն, քան անալոգային համակարգիչները եւ ավելի հաճախ
    են օգտագործվում այսօրվա շուկայում:
    Վերջիվերջո, համակարգիչների դասակարգումը կարող է նաեւ հիմնված լինել նպատակի վրա։ Անհատական համակարգիչները
    նախատեսված են անձնական օգտագործման համար, իսկ գործարար համակարգիչները նախատեսված են աշխատավայրում օգտագործելու համար:
    Սերվերները նախատեսված են մեծ քանակությամբ տվյալներ ձեռք բերելու եւ այլ համակարգիչներին ցանցային ծառայություններ
    մատուցելու համար: Սուպերհամակարգիչները ամենահզոր համակարգիչներն են եւ օգտագործվում են բարդ գիտական եւ ինժեներական սիմուլյացիաների համար։
    Ամփոփելով՝ համակարգիչների դասակարգումը կարեւոր ուղղություն է հասկանալու համար այն սարքերի տարբեր տեսակները,
    որոնք այսօր առկա են շուկայում: Այն հիմնված է մի քանի գործոնների վրա, ինչպիսիք են չափը, օգտագործումը, տեսակը
    եւ նպատակը։ Համակարգիչների դասակարգումը հասկանալը կարող է օգնել օգտագործողներին ճիշտ որոշումներ կայացնել համակարգիչ գնելիս կամ օգտագործելիս։</p>
</div>
<div class="stack">
<h1 id="stack">
    Stack vs Heap Memory - Difference Between Them
</h1>
<p>
                   <h2>Ստակի եւ հեփի հիշողության հիմնական տարբերություն</h2>
                </li> Stack-ը գծային տվյալների կառուցվածք է, մինչդեռ Heap-ը հիերարխիկ տվյալների կառուցվածք է։</li>
    
            </li> Stack հիշողությունը երբեք չի բեկվի, մինչդեռ Heap հիշողությունը կարող է մասնատվել, քանի որ հիշողության բլոկները սկզբում բաշխվում են, իսկ հետո ազատվում:</li>
    
        </li>   Stack-ը մուտք է գործում տեղական փոփոխականներ միայն այն ժամանակ, երբ Heap-ը թույլ է տալիս ձեզ մուտք գործել փոփոխականներ ամբողջ աշխարհում:</li>
    
    </li>  Stack փոփոխականները հնարավոր չէ վերամշակել, մինչդեռ Heap փոփոխականները կարող են վերամշակվել:</li>
    
</li>  Stack բաշխումը կատարվում է կոմպիլյատորի հրահանգներով, մինչդեռ Heap allocation եւ deallocation կատարվում է ծրագրավորողի կողմից:</li>
    
    
    
<h2>Հեփի օգտագործման առավելությունները	</h2>
    
   <ul>
     <li>Heap-ն օգնում է գտնել մեծագույն եւ նվազագույն թիվը</li>
    <li> Աղբի հավաքումը գործում է կույտի հիշողության վրա, որպեսզի ազատի օբյեկտի օգտագործած հիշողությունը:</li>
<li>  Այն թույլ է տալիս ձեզ մուտք գործել փոփոխականներ ամբողջ աշխարհում:</li>
<li> Heap-ը հիշողության չափի սահմանափակում չունի:</li></ul>
   </ul>
    
    
<h2> Սթեք օգտագործելու առավելությունները</h2>
    
   <ul><li>Օգնում է ձեզ կառավարել տվյալները</li>
   <li> Այն թույլ է տալիս վերահսկել, թե ինչպես է հիշողությունը բաշխվում եւ լուծվում։</li>
<li> Stack ավտոմատ մաքրում է օբյեկտը:</li>
<li>Փոփոխականները հնարավոր չէ վերամշակել։</li></ul>
    
    
<h2> Սթեք օգտագործելու թերությունները</h2>
<ul>  <li>Stack հիշողությունը շատ սահմանափակ է:</li>
<li> Կույտի վրա չափից շատ առարկաներ ստեղծելը կարող է մեծացնել կույտի գերհոսքի վտանգը։</li>
<li> Հնարավոր չէ պատահական մուտք գործել։</li>
<li>  Փոփոխական պահուստը կգրվի գերանորոգված, ինչը երբեմն հանգեցնում է ֆունկցիայի կամ ծրագրի չսահմանված վարքագծի:</li>
<li>  Կույտը կընկնի հիշողության տարածքից դուրս, ինչը կարող է հանգեցնել ոչ նորմալ ընդհատման։</li></ul>
    
    
<h2> Heap-ի օգտագործման թերությունները</h2>
<ul> <li> Այն կարող է ապահովել առավելագույն հիշողությունը, որը OS-ը կարող է տրամադրել</li>
<li>Հաշվարկելու համար ավելի շատ ժամանակ է հարկավոր։</li>
<li>  Հիշողության կառավարումը ավելի բարդ է կուտակման հիշողության մեջ, քանի որ այն օգտագործվում է ամբողջ աշխարհում։</li>
<li> Չափից շատ ժամանակ է պահանջվում մահապատժի ենթարկվելու համար ՝ համեմատած կույտի հետ </li></ul></div>
<div class="m"><h1 id="kompilator">Compiler vs Interpreter</h1></p>
 <p>
<p>   
    Ինտերպրետատորները(թարգմանիչ) և կոմպիլյատորները(կազմող) պատասխանատու են ծրագրավորման լեզուն կամ 
    սցենարը (բարձր մակարդակի լեզուն) մեքենայական կոդի վերածելու համար: Բայց եթե երկու ծրագրերն էլ
     նույնն են անում, ինչո՞վ են դրանք տարբերվում: Եկե՛ք պարզենք:
     <h2>Կոմպիլյատոր`</h2>
Կոմպիլյատորը (անգլ.՝ compiler) ծրագիր է, որը փոխակերպում է ծրագրավորման լեզվով գրված սկզբանական կոդը 
( անգլ.՝ source code) այլ ծրագրային լեզվով(ելքային լեզվի, անգլ.՝ target language) կոդի, որը հիմնականում ունի բինար տեսք և հայտնի է օբյեկտային կոդ
 (անգլ.՝ object code) անվանմամբ։ Սկզբնական կոդի փոխակերպման ամենատարածված պատճառը այն է որ ստեղծվի կատարվող ծրագիր 
 (անգլ.՝ executable program): Այն կարող է կատարել բոլոր նշված օպերացիաները
</p>

   <ul><li>լեքսիկական վերլուծություն ( անգլ.՝ lexical analysis) – Այս փուլում սկզբնական ֆայլի սիմվոլների հաջորդականությունը փոխակերպվում է թոքենների հաջորդականության։</li>
   <li>սինտակտիկական (քերականական) անալիզ (անգլ.՝ Parsing) – թոքենների հաջորդականությունը փոխակերպվում է վերլուծության ծառի (parse tree):</li>
<li> 
սեմանտիկական (իմաստային) անալիզ (անգլ.՝ semantic analysis) – վերլուծության ծառը մշակվում է իմաստը հաստատելու նմատակով։ Օրինակ՝ իդենտիֆիկատորների կապը դրանց հայտարարմանը, տիպերին, համատեղելիության ստուգումը և այլն։ Արդյունքը հիմնականում կոչվում է կոդի միրջանկյալ ներկայացում (անգլ.՝ intermediate representation) և կարող է լինել վերլուծության ծառի լրացում, նոր ծառ, աբստրակտ հրամանների խումբ կամ այլ բան՝ հարմար հետագա աշխատանքին։</li>
<li>կոդի օպտիմիզացիա ( անգլ.՝ code optimization) – կատարվում է ավելորդ կոնստրուկցիաների հեռացում և կոդի պարզեցում՝ իմաստը պահպանելով։</li>
<li>կոդի գեներացիա (անգլ.՝ code generation) – միջանկյալ ներկայացումից առաջանում է ելքային կոդ (անգլ.՝ target code)։</li></ul>
<br/>Այսպիսով, կոմպիլյատորը վերցնում է ծրագիրն ամբողջությամբ և փոխակերպում այն ​​գործարկվող համակարգչային կոդի:
 Սա պահանջում է մի ամբողջ ծրագիր, քանի որ համակարգիչը հասկանում է միայն երկուական կոդ: Ուստի կոմպիլյատորի
  խնդիրն է գործարկվող ծրագիրը վերածել մեքենայի կոդի, որը ճանաչվում է համակարգչի կողմից:

<p>Կոմպիլյացնող ծրագրավորման լեզուների օրինակներ են C, C++, Java-ն:</p>

   <h2>Ինտերպրետատոր</h2>
   <p>Ինտերպրետատորը (անգլ.՝ interpreter) ծրագիր է, որն ուղղակիորեն կատարում է ծրագրավորման կամ սկրիպտավորման 
   լեզուներով գրված հրամաններ, առանց դրանք նախապես կոմպիլյացնելով մեքենայական լեզվի ծրագրի։ Ինտերպրետատորը
    ծրագրի կատարման համար հիմնականում օգտագործում է հետևյալ ստրատեգիաներից մեկը՝</p>

    <p><ul>
        <li>վերլուծել (անգլ.՝ parse) սկզբնական կոդը և ուղղակիորեն կատարել,</li>
    <li>թարգմանել սկզբնական կոդը, ինչ որ միջանկյալ տեսքի և իրականացնել այն,</li>
<li>հստակ իրականացնել պահպանված նախակոմպիլյացված (անգլ.՝ precompiled) կոդը՝ կոմպիլյատորի կողմից կազմված, որը հանդիսանում է ինտերպրետատորի համակարգի մի մաս։</li>
    </ul></p>
    <p>Այսինքն ինտերպրետատորը մեքենայական ծրագիր է, որն ուղղակիորեն կատարում է մի շարք հրահանգներ՝ առանց դրանք նախապես կոմպիլյացնելու: Ինտերպրետացվող լեզուների օրինակներ են Perl-ը, Python-ը, Matlab-ը, Javascript-ը, PHP-ն:</p>

<p><br/>Որպես վերը նշվածների կարճ ամփոփում՝ կարելի է նշել, որ թե՛ կոմպիլյատորը և թե՛
 ինտերպրետատորը կատարում են նույն գործառույթը՝ բարձր մակարդակի ծրագրավորման 
 լեզուն փոխակերպելով մեքենայական կոդի: Այնուամենայնիվ, կոմպիլյատորը սկզբնական կոդը 
 փոխակերպում է մեքենայի կոդի՝ ծրագիրը գործարկելուց առաջ: Ինտերպրետատորը կատարում է այս
  ֆունկցիան, երբ այն գործարկվում է, գործարկման հետ միաժամանակ:</p>

  <h2>Ինչպե՞ս է այս ամենն աշխատում</h2>
<p>
    <strong>Կոմպիլյատորը</strong> նախ ստեղծում է ծրագիր: Այն վերլուծում է լեզվի բոլոր օպերատորներին` ստուգելու, թե դրանք ճիշտ են, թե՝ ոչ: Եթե ​​կոմպիլյատորը որևէ սխալ գտնի, այն համապատասխան հաղորդագրություն կտա և կդադարեցնի կոմպիլյացման պրոցեսը: Հակառակ դեպքում այն սկզբնաղբյուրը կոդը փոխակերպում է մեքենայական կոդի: Կոմպիլյատորը տարբեր կոդային ֆայլեր է կապում այն ​​ծրագրերի հետ, որոնք կարող եք գործարկվել(օրինակ .exe ֆորմատով): Դրանից հետո ծրագիրը մեկնարկվում է:

   <br/> <strong>Ինտերպրետատորը</strong> նույնպես, առաջին հերթին ստեղծում է ծրագիր: Այն չի կապում ֆայլերը կամ չի ստեղծում մեքենայական կոդ. պարզապես ծրագրի կատարման ընթացքումտեղի է ունենում մուտքային օպերատորների կատարում՝ տող առ տող:
</p>
<h2>Առավելություններ և թերություններ</h2>
   <h3>Կոմպիլյատորի առավելությունները</h3>
   <p><ul>
   <li>Ծրագրային կոդը բերվում է մեքենայական կոդի, ինչի իրականացման համար շատ ավելի քիչ ժամանակ է պահանջվում</li> 
<li> .exe ֆայլերն աշխատում են ավելի արագ, քան սկզբաղբյուր կոդը: Օբյեկտային ծրագրերը պահպանվում են և կարող են գործարկվել ցանկացած պահի</li> 
<li> Օբյեկտային ծրագրեը երրորդ կողմից ավելի են պաշտպանված: Օգտագործողն այն ավելի դժվարությամբ կարող է փոփոխել, քան սկզբնաղբյուր կոդը</li> 
<li> Կոմպիլյատորը սինտաքսային սխալների առկայությունը ստուգում է կոմպիլյացման ընթացքում, ինչը բացառում է գործարկումից հետո սինտաքսային սխալի առաջացումը</li> 
   </ul></p>
   <h3>Կոմպիլյատորի թերությունները</h3>
   <ul><li>Քանզի թարգմանվում է ծրագիրն ամբողջությամբ, օգտագործվում է շատ ավելի մեծ մեքենայական հիշողության ռեսուրս</li>
   <li>Յուրաքանչյուր փոփոխության համար պետք է փոխել սկզբնաղբյուր կոդը և կրկնել կոմպիլյացիայի պրոցեսը</li>
<li>  Նախքան վերջնական կատարվող ֆայլի ստեղծումը անհրաժեշտ է ստեղծել նաև օբյեկտային ծրագիր, ինչը ևս ժամանակատար պրոցես է</li>
<li>Սկզբնաղբյուր կոդը պետք է լինի 100% ճիշտ կատարվող ֆայլ ստեղծելու համա</li></ul>
<h3>Ինտերպրետատորի առավելությունները</h3>
<ul><li>Ինտերպրետատորը զգալիորեն թեթևացնում է սկզբնաղբյուր կոդի հետ աշխատանքը</li>
<li>Այն միաժամանակ թարգմանում է մեկ հրահանգ, ուստի օգտագործում է նվազագույն քանակությամբ հիշողություն</li>
<li>Ինտերպրետատորը կարող է սխալների մասին հաղորդագրությունները կապել կատարվող հրահանգների հետ, որը կարող է օգտակար լինել վրիպազերծման (դեբագի) ժամանակ:</li></ul>

<h3>Ինտերպրետատորի թերությունները</h3>
<ul><li>Ամեն անգամ, երբ ծրագիրը կատարվում է, զգալի ժամանակ է վատնվում ինտերպրետացիայի վրա, ինչի հետևանքով ձգձգում է կատարման ժամանակը:</li>
<li>Ինտերպրետացվող ծրագրերը կարող են գործարկվել միայն այն համակարգիչների վրա, որոնք ունեն համապատասխան ինտերպրետատորները:</li></ul>
<h2>Տարբերություններ</h2>
<h3>Եզրափակենք կամպիլյատորի և ինտերպրետատորի տարբերությունները աղյուսակի միջոցով.</h3>

<img src="comiler-interprerier-cycles.jpg.webp" alt="mmm">
<table>
    <tr>
        <th bgcolor="grey">Կամպիլյատոր</th>
        <th bgcolor="grey">Ինտերպրետատոր</th>
    </tr>
    <tr>
<tr>
   <th>Կամպիլյատորը լեզվական պրոցեսսոր է, որը փոխարկում է բարձր մակարդակի լեզուն ցածրի, և հակառակը</th>



   <th>Ինտերպրետատորը լեզվական պրոցեսսոր է, որը փոխարկում է բարձր մակարդակի լեզուն ցածրի, և հակառակը</th>
</tr>









    </tr>













</table>













    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    
    </p>
</div>


 


































































</div>
</body>
</html>
